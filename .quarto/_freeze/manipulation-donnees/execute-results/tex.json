{
  "hash": "0962817e5bfd9eb91382e22b82b44a4c",
  "result": {
    "markdown": "# Introduction aux verbes de dplyr\n\nLa manipulation de donn√©es est l'une des comp√©tences les plus importantes en science des donn√©es, car elle permet de nettoyer, transformer et regrouper des donn√©es brutes en des ensembles de donn√©es utiles et informatifs. R est un langage de programmation populaire pour la science des donn√©es qui offre une grande vari√©t√© de fonctions et de packages pour effectuer ces t√¢ches. De la s√©lection de colonnes sp√©cifiques √† la transformation de donn√©es en utilisant des fonctions personnalis√©es, en passant par la fusion de ensembles de donn√©es diff√©rents, la manipulation de donn√©es avec R est un art qui n√©cessite une bonne compr√©hension des outils adapt√©s. Dans ce chapitre, nous allons explorer les techniques de la manipulation de donn√©es avec R et quelques packages dont principalement `dplyr`.\n\n## Introduction au pipe (`%>%`)\n\nQuand on manipule un tableau de donn√©es, il est tr√®s fr√©quent d'encha√Æner plusieurs op√©rations. On va par exemple extraire une sous-population avec `filter`, s√©lectionner des colonnes avec `select` puis trier selon une variable avec `arrange`, etc.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ncounties <- readRDS(\"data/counties.rds\")\n```\n:::\n\n\n\nTRaditionnellement, nous pouvons √©crire ceci :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(\n  ungroup(\n  slice_max(\n  summarize(\n    group_by(counties, state, metro), \n    total_pop = sum(population)),\n  total_pop, n = 1)), \n  metro)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  metro        n\n  <chr>    <int>\n1 Metro       44\n2 Nonmetro     6\n```\n:::\n:::\n\n\n\nPour simplifier et am√©liorer la lisibilit√© du code, on va utiliser un op√©rateur, pipe. Le pipe se note `%>%`, et son fonctionnement est le suivant : si j'ex√©cute expr `%>%` f, alors le r√©sultat de l'expression expr, √† gauche du pipe, sera pass√© comme premier argument √† la fonction f, √† droite du pipe, ce qui revient √† ex√©cuter `f(expr)`.\n\nAinsi le premier code peut s'\"crire comme suit, en utilisant le pipe :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  group_by(state, metro) %>%\n  summarize(total_pop = sum(population)) %>%\n  slice_max(total_pop, n = 1) %>%\n  ungroup() %>%\n  count(metro)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  metro        n\n  <chr>    <int>\n1 Metro       44\n2 Nonmetro     6\n```\n:::\n:::\n\n\n\nOn voit bien ce code est plus clair, car les op√©rations sont √©crites dans l'ordre naturelle.\n\nLes donn√©es (`counties`) que nous allons utiliser contiennent les comt√©s des diff√©rents Etats aux USA avec des diff√©rents indicateurs.\n\n## Les verbes de dplyr\n\nManipuler les donn√©es avec dplyr se fait au moyen d'un certain nombre de verbes qui indique l'action √† ex√©cuter le tableau de donn√©es (data.frame/tibble). Toutes les fonctions que nous verons prennent un dataframe en entr√©e et retourne √©galement un datafrme.\n\n### select\n\nPermet de s√©lectionner une ou plusieurs colonnes d'un tableau de donn√©e.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  # Selectionner 4 colonnes\n  select(state, county, population, poverty)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 4\n   state   county   population poverty\n   <chr>   <chr>         <dbl>   <dbl>\n 1 Alabama Autauga       55221    12.9\n 2 Alabama Baldwin      195121    13.4\n 3 Alabama Barbour       26932    26.7\n 4 Alabama Bibb          22604    16.8\n 5 Alabama Blount        57710    16.7\n 6 Alabama Bullock       10678    24.6\n 7 Alabama Butler        20354    25.4\n 8 Alabama Calhoun      116648    20.5\n 9 Alabama Chambers      34079    21.6\n10 Alabama Cherokee      26008    19.2\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nLes `:` permettent de s√©lectionner des colonnes qui se suivent.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(metro : black)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 7\n   metro    population   men women hispanic white black\n   <chr>         <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>\n 1 Metro         55221 26745 28476      2.6  75.8  18.5\n 2 Metro        195121 95314 99807      4.5  83.1   9.5\n 3 Nonmetro      26932 14497 12435      4.6  46.2  46.7\n 4 Metro         22604 12073 10531      2.2  74.5  21.4\n 5 Metro         57710 28512 29198      8.6  87.9   1.5\n 6 Nonmetro      10678  5660  5018      4.4  22.2  70.7\n 7 Nonmetro      20354  9502 10852      1.2  53.3  43.8\n 8 Metro        116648 56274 60374      3.5  73    20.3\n 9 Nonmetro      34079 16258 17821      0.4  57.3  40.3\n10 Nonmetro      26008 12975 13033      1.5  91.7   4.8\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nLa commande suivante permet de s√©lectionner les colonnes dont les noms commencent avec \"in\".\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(starts_with(\"in\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 4\n   income income_err income_per_cap income_per_cap_err\n    <dbl>      <dbl>          <dbl>              <dbl>\n 1  51281       2391          24974               1080\n 2  50254       1263          27317                711\n 3  32964       2973          16824                798\n 4  38678       3995          18431               1618\n 5  45813       3141          20532                708\n 6  31938       5884          17580               2055\n 7  32229       1793          18390                714\n 8  41703        925          21374                489\n 9  34177       2949          21071               1366\n10  36296       1710          21811               1556\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nOn peut aussi utiliser `contains()` ou `ends_with()` pour s√©lectionner respectivement les colonnes qui contiennent ou se se terminent par une cha√Æne de caract√®re donn√©e. Des colonnes peuvent √™tre exclues du r√©sultat par le signe (-). On peut par exemple exclure les 6 premi√®res colonnes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(-c(1 : 6))\n```\n:::\n\n\n\nüëâ S√©lectionnez les colonnes dont les noms se terminent par \"tion\". Le r√©sultat devrait ressembler √† √ßa :\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 3\n   population construction production\n        <dbl>        <dbl>      <dbl>\n 1      55221          8.6       17.1\n 2     195121         10.8       11.2\n 3      26932         10.8       23.1\n 4      22604         19         23.7\n 5      57710         13.5       19.9\n 6      10678         20.1       26.4\n 7      20354         10.3       23.7\n 8     116648         10.5       20.4\n 9      34079         11.5       24.4\n10      26008         13.7       21.5\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\n### arrange\n\nPermet de trier une colonne selon un ordre donn√©.\n\nPar d√©faut, `arrange()` trie le r√©sultat par ordre croissant.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected <- counties %>%\n  select(region, state, county, public_work, population, private_work, women, citizens, work_at_home, walk, land_area)\n\ncounties_selected %>%\n  arrange(public_work)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 11\n   region      state county publi~1 popul~2 priva~3  women citiz~4 work_~5  walk\n   <chr>       <chr> <chr>    <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n 1 North Cent~ Ohio  Holmes     5.8   43436    81.3  21690   28871     8.9   6.9\n 2 North Cent~ Nebr~ McPhe~     5.9     433    69.4    210     341    22.6  15.7\n 3 North Cent~ Indi~ LaGra~     6.6   38084    84.1  18851   24533     6.1   2.9\n 4 North Cent~ Indi~ Kosci~     6.9   77983    88.3  39113   56795     3.8   2.1\n 5 North Cent~ Indi~ Spenc~     6.9   20856    86.3  10299   15889     3.6   1.2\n 6 North Cent~ Nebr~ Dakota     7.3   20798    87.3  10698   12585     2.5   1.9\n 7 North Cent~ Illi~ Jersey     7.5   22625    86.6  11567   17534     3.8   3.3\n 8 North Cent~ Indi~ Clint~     7.5   32835    87.5  16670   22754     2.9   1.1\n 9 North Cent~ Indi~ Barth~     7.6   79488    87.8  39954   55362     2.2   1.6\n10 North Cent~ Indi~ Elkha~     7.7  200685    87.5 101510  132834     2.9   1.6\n# ... with 3,128 more rows, 1 more variable: land_area <dbl>, and abbreviated\n#   variable names 1: public_work, 2: population, 3: private_work, 4: citizens,\n#   5: work_at_home\n```\n:::\n:::\n\n\n\nOn peut obtenir le r√©sultat par ordre d√©croissant avec la fonction `desc()` comme suit :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # trier par ordre d√©croissant de 'public_work'\n  arrange(desc(public_work))\n```\n:::\n\n\n\nüëâ Quelle est la comt√© avec la plus grande population et celle avec la petite populaion?\n\n\n\n\n\n\n\n\n\n### filter\n\nPermet de s√©lectionner des lignes d'un dataframe selon une ou plusieurs conditions.\n\nLa commande suivante permet de filtrer les comt√©s ayant une population sup√©rieure √† 1000000.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # filtrer les comt√©s avec une population sup √† 1000000\n  filter(population > 1000000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 41 x 11\n   region state      county publi~1 popul~2 priva~3  women citiz~4 work_~5  walk\n   <chr>  <chr>      <chr>    <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n 1 West   Arizona    Maric~    11.7  4.02e6    82.5 2.03e6 2659853     5.9   1.6\n 2 West   California Alame~    13.8  1.58e6    78.7 8.08e5 1025865     5.6   3.7\n 3 West   California Contr~    13.6  1.10e6    77.5 5.61e5  720881     5.8   1.7\n 4 West   California Los A~    11.5  1.00e7    79   5.09e6 6046749     5.1   2.8\n 5 West   California Orange    10.2  3.12e6    81.8 1.58e6 1961585     5.2   2  \n 6 West   California River~    14.9  2.30e6    77.1 1.15e6 1427761     5.2   1.4\n 7 West   California Sacra~    21.8  1.47e6    70.8 7.49e5  985653     5.1   2.2\n 8 West   California San B~    16.7  2.09e6    76.4 1.05e6 1292879     4.2   1.8\n 9 West   California San D~    14.8  3.22e6    77.3 1.60e6 2141755     6.8   2.9\n10 West   California Santa~     9.3  1.87e6    84.3 9.29e5 1131378     4.6   2  \n# ... with 31 more rows, 1 more variable: land_area <dbl>, and abbreviated\n#   variable names 1: public_work, 2: population, 3: private_work, 4: citizens,\n#   5: work_at_home\n```\n:::\n:::\n\n\n\nOn peut combiner plusieurs conditions avec des op√©rateurs(\\| pour OU, & et ',' pour ET, == pour l'√©galit√©).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # filtrer les comt√©s avec une population sup √† 1000000 √† California\n  filter(population > 1000000, state == \"California\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 11\n  region state      county  publi~1 popul~2 priva~3  women citiz~4 work_~5  walk\n  <chr>  <chr>      <chr>     <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n1 West   California Alameda    13.8  1.58e6    78.7 8.08e5 1025865     5.6   3.7\n2 West   California Contra~    13.6  1.10e6    77.5 5.61e5  720881     5.8   1.7\n3 West   California Los An~    11.5  1.00e7    79   5.09e6 6046749     5.1   2.8\n4 West   California Orange     10.2  3.12e6    81.8 1.58e6 1961585     5.2   2  \n5 West   California Rivers~    14.9  2.30e6    77.1 1.15e6 1427761     5.2   1.4\n6 West   California Sacram~    21.8  1.47e6    70.8 7.49e5  985653     5.1   2.2\n7 West   California San Be~    16.7  2.09e6    76.4 1.05e6 1292879     4.2   1.8\n8 West   California San Di~    14.8  3.22e6    77.3 1.60e6 2141755     6.8   2.9\n9 West   California Santa ~     9.3  1.87e6    84.3 9.29e5 1131378     4.6   2  \n# ... with 1 more variable: land_area <dbl>, and abbreviated variable names\n#   1: public_work, 2: population, 3: private_work, 4: citizens,\n#   5: work_at_home\n```\n:::\n:::\n\n\n\nPlusieurs verbes peuvent √™tre encha√Æn√©s avec le pipe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  filter(state == \"Texas\", population > 10000) %>%\n  arrange(desc(private_work))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 169 x 11\n   region state county  public_work popul~1 priva~2  women citiz~3 work_~4  walk\n   <chr>  <chr> <chr>         <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n 1 South  Texas Gregg           9.8  123178    84.7 6.28e4   84342     2.1   1.6\n 2 South  Texas Collin         10    862215    84.1 4.39e5  548008     7.8   0.8\n 3 South  Texas Dallas          9.5 2485003    83.9 1.26e6 1432702     4.1   1.5\n 4 South  Texas Harris         10.1 4356362    83.4 2.19e6 2494733     3.3   1.5\n 5 South  Texas Andrews         9.6   16775    83.1 8.22e3   10207     2.5   0.1\n 6 South  Texas Tarrant        11.4 1914526    83.1 9.77e5 1219370     3.9   1.2\n 7 South  Texas Titus          10     32553    82.5 1.65e4   18834     1.8   1  \n 8 South  Texas Denton         11.9  731851    82.2 3.72e5  482962     6.2   1.2\n 9 South  Texas Ector          11.2  149557    82   7.44e4   92579     2.1   1.1\n10 South  Texas Moore          11.7   22281    82   1.08e4   11050     1.6   1.7\n# ... with 159 more rows, 1 more variable: land_area <dbl>, and abbreviated\n#   variable names 1: population, 2: private_work, 3: citizens, 4: work_at_home\n```\n:::\n:::\n\n\n\n### mutate\n\nPermet d'ajouter une nouvelle variable dans le dataframe. Elle est souvent utiliser pour cr√©er une variable √† partir sur base d'un calcul.\n\nLa commande suivante permet cr√©er une variable qui contient le nombre d'employ√©s du secteur public `public_workers` √† partir de `population` et `public_work`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  mutate(public_workers = population * public_work / 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 12\n   region state   county   public_~1 popul~2 priva~3 women citiz~4 work_~5  walk\n   <chr>  <chr>   <chr>        <dbl>   <dbl>   <dbl> <dbl>   <dbl>   <dbl> <dbl>\n 1 South  Alabama Autauga       20.9   55221    73.6 28476   40725     1.8   0.5\n 2 South  Alabama Baldwin       12.3  195121    81.5 99807  147695     3.9   1  \n 3 South  Alabama Barbour       20.8   26932    71.8 12435   20714     1.6   1.8\n 4 South  Alabama Bibb          16.1   22604    76.8 10531   17495     0.7   0.6\n 5 South  Alabama Blount        13.5   57710    82   29198   42345     2.3   0.9\n 6 South  Alabama Bullock       15.1   10678    79.5  5018    8057     2.8   5  \n 7 South  Alabama Butler        16.2   20354    77.4 10852   15581     1.7   0.8\n 8 South  Alabama Calhoun       20.8  116648    74.1 60374   88612     2.7   1.2\n 9 South  Alabama Chambers      12.1   34079    85.1 17821   26462     2.1   0.3\n10 South  Alabama Cherokee      18.5   26008    73.1 13033   20600     2.5   0.6\n# ... with 3,128 more rows, 2 more variables: land_area <dbl>,\n#   public_workers <dbl>, and abbreviated variable names 1: public_work,\n#   2: population, 3: private_work, 4: citizens, 5: work_at_home\n```\n:::\n:::\n\n\n\nOn peut savoir la comt√© avec le plus grand nombre de d'employ√©s du secteur public.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  mutate(public_workers = public_work * population / 100) %>%\n  arrange(desc(public_workers)) %>% \n  select(state, county, public_workers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 3\n   state      county         public_workers\n   <chr>      <chr>                   <dbl>\n 1 California Los Angeles          1154415.\n 2 Illinois   Cook                  602185.\n 3 California San Diego             477018.\n 4 Arizona    Maricopa              470123.\n 5 Texas      Harris                439993.\n 6 New York   Kings                 373717.\n 7 California San Bernardino        349826.\n 8 California Riverside             342407.\n 9 California Sacramento            319551.\n10 California Orange                317839.\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nüëâ Quelles sont les 5 comt√©s ayant la plus grande proportion des femmes ?\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n  state       county        proportion_women\n  <chr>       <chr>                    <dbl>\n1 Virginia    Norton city              0.594\n2 Georgia     Pulaski                  0.580\n3 Alabama     Sumter                   0.557\n4 Mississippi Sharkey                  0.555\n5 Virginia    Franklin city            0.555\n```\n:::\n:::\n\n\n\n### count\n\nPermet de compter le nombre d'occurrence de valeurs d'une variable qualitative.\n\nLe code suivant permet de compter le nombre de comt√©s dans chaque r√©gion.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  count(region, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 2\n  region            n\n  <chr>         <int>\n1 South          1420\n2 North Central  1054\n3 West            447\n4 Northeast       217\n```\n:::\n:::\n\n\n\n`count()` dispose d'un argument `wt` qui permet de fournir une variable quantitative pour effectuer la somme. La commande suivante calcule la somme de la variable `citizens` pour chaque region.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  count(region, wt = citizens, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 2\n  region               n\n  <chr>            <dbl>\n1 South         83019572\n2 North Central 49472719\n3 West          49415038\n4 Northeast     40058582\n```\n:::\n:::\n\n\n\nLe nombre de personnes qui travaillent √† la maison dans chaque √©tat peut √™tre obtenu avec la commande suivante :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  mutate(pop_work_at_home = population * work_at_home / 100) %>% \n  count(state, wt = pop_work_at_home, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 x 2\n   state                 n\n   <chr>             <dbl>\n 1 California     2026868.\n 2 Texas          1070728.\n 3 Florida        1006787.\n 4 New York        762667.\n 5 Illinois        539101.\n 6 Pennsylvania    505435.\n 7 Georgia         470379.\n 8 North Carolina  446695.\n 9 Ohio            405370.\n10 Washington      380857.\n# ... with 40 more rows\n```\n:::\n:::\n\n\n\nüëâ Calculer le nombre de personnes qui font la marche pour se rendre au travail.\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 x 2\n   state                n\n   <chr>            <dbl>\n 1 New York      1237938.\n 2 California    1017964.\n 3 Pennsylvania   505397.\n 4 Texas          430783.\n 5 Illinois       400346.\n 6 Massachusetts  316765.\n 7 Florida        284723.\n 8 New Jersey     273047.\n 9 Ohio           266911.\n10 Washington     239764.\n# ... with 40 more rows\n```\n:::\n:::\n\n\n\n### summarize\n\nPermet de calculer un sommaire sur une variable quantitative. Exp: moyenne, √©cart-type\n\nLa commande suivante compte le nombre d'observations dans le tableau de donn√©es.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 1\n      n\n  <int>\n1  3138\n```\n:::\n:::\n\n\n\nNous pouvons calcaler plusieurs statistiques telles que la moyenne, minimum, √©cart-type et autres comme sur la commande suivante :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  summarise(\n    # calcule le minimum\n    min_population = min(population),\n    # calcule la moyenne\n    mean_population = mean(population),\n    # calcule le maximum\n    max_population = max(population)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n  min_population mean_population max_population\n           <dbl>           <dbl>          <dbl>\n1             85         100652.       10038388\n```\n:::\n:::\n\n\n\n### group_by() / ungroup()\n\nPermet de grouper un dataframe en fonction d'une variable qualitative. Cela permet d'effectuer des op√©rations sur ce groupe.\n\nLe groupe n'a de valeur que lorsqu'il est combin√© avec d'autres verbes. Des exemples sont fournis ci-apr√®s :\n\n-   Calculer pour chaque Etat, la superficie et la population totale.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # Group by state \n  group_by(state) %>%\n  # Find the total area and population\n  summarise(\n    total_area = sum(land_area),\n    total_population = sum(population)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 x 3\n   state       total_area total_population\n   <chr>            <dbl>            <dbl>\n 1 Alabama         50645.          4830620\n 2 Alaska         553560.           725461\n 3 Arizona        113594.          6641928\n 4 Arkansas        52035.          2958208\n 5 California     155779.         38421464\n 6 Colorado       103642.          5278906\n 7 Connecticut      4842.          3593222\n 8 Delaware         1949.           926454\n 9 Florida         53625.         19645772\n10 Georgia         57514.         10006693\n# ... with 40 more rows\n```\n:::\n:::\n\n\n\nOn peut ajouter des verbes √† la commande pr√©c√©dente pour calculer la densit√© et la trier par ordre d√©croissant.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  group_by(state) %>%\n  summarize(total_area = sum(land_area),\n            total_population = sum(population)) %>%\n  mutate(density = total_population / total_area) %>%\n  arrange(desc(density))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 x 4\n   state         total_area total_population density\n   <chr>              <dbl>            <dbl>   <dbl>\n 1 New Jersey         7354.          8904413   1211.\n 2 Rhode Island       1034.          1053661   1019.\n 3 Massachusetts      7800.          6705586    860.\n 4 Connecticut        4842.          3593222    742.\n 5 Maryland           9707.          5930538    611.\n 6 Delaware           1949.           926454    475.\n 7 New York          47126.         19673174    417.\n 8 Florida           53625.         19645772    366.\n 9 Pennsylvania      44743.         12779559    286.\n10 Ohio              40861.         11575977    283.\n# ... with 40 more rows\n```\n:::\n:::\n\n\n\n-   L'Etat avec le plus faible revenu dans chaque region\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected <- counties %>%\n  select(region, state, county, population, income)\n\ncounties_selected %>%\n  group_by(region, state) %>%\n  # Calculate average income\n  summarise(average_income = mean(income)) %>%\n  # Find the lowest income state in each region\n  slice_min(average_income, n = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'region'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 3\n# Groups:   region [4]\n  region        state       average_income\n  <chr>         <chr>                <dbl>\n1 North Central Missouri            41755.\n2 Northeast     Maine               46142.\n3 South         Mississippi         34939.\n4 West          New Mexico          40184.\n```\n:::\n:::\n\n\n\n-   Deux Etats avec le taux de pauvret√© le plus √©lev√© dans chaque region\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  group_by(region, state) %>% \n  summarise(average_poverty = mean(poverty)) %>% \n  slice_max(average_poverty, n = 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'region'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 x 3\n# Groups:   region [4]\n  region        state       average_poverty\n  <chr>         <chr>                 <dbl>\n1 North Central Missouri               18.1\n2 North Central Michigan               16.7\n3 Northeast     Maine                  15.1\n4 Northeast     New York               14.5\n5 South         Mississippi            25.7\n6 South         Georgia                22.2\n7 West          Arizona                21.3\n8 West          New Mexico             21.1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  group_by(region) %>%\n  summarise(across(ends_with(\"tion\"), mean, .names = \"mean_{.col}\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 4\n  region        mean_population mean_construction mean_production\n  <chr>                   <dbl>             <dbl>           <dbl>\n1 North Central          64072.              12.1            17.4\n2 Northeast             258016.              10.0            13.3\n3 South                  83048.              13.1            16.4\n4 West                  166434.              14.5            11.7\n```\n:::\n:::\n\n\n\n### rename\n\nPermet de renommer le nom d'une colonne (variable). La syntaxe est la suivante : `rename(nouveau_nom = ancien_nom)`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected <- counties %>%\n  select(census_id, region, state, county, population, income)\n\ncounties_selected %>% \n  rename(id = census_id, us_state = state)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 6\n   id    region us_state county   population income\n   <chr> <chr>  <chr>    <chr>         <dbl>  <dbl>\n 1 1001  South  Alabama  Autauga       55221  51281\n 2 1003  South  Alabama  Baldwin      195121  50254\n 3 1005  South  Alabama  Barbour       26932  32964\n 4 1007  South  Alabama  Bibb          22604  38678\n 5 1009  South  Alabama  Blount        57710  45813\n 6 1011  South  Alabama  Bullock       10678  31938\n 7 1013  South  Alabama  Butler        20354  32229\n 8 1015  South  Alabama  Calhoun      116648  41703\n 9 1017  South  Alabama  Chambers      34079  34177\n10 1019  South  Alabama  Cherokee      26008  36296\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nSi l'on d√©sire ne garder que les colonnes r√©nomm√©es, on peut utiliser `select()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(id = census_id, us_state = state)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 2\n   id    us_state\n   <chr> <chr>   \n 1 1001  Alabama \n 2 1003  Alabama \n 3 1005  Alabama \n 4 1007  Alabama \n 5 1009  Alabama \n 6 1011  Alabama \n 7 1013  Alabama \n 8 1015  Alabama \n 9 1017  Alabama \n10 1019  Alabama \n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\n### transmute\n\nPermet de s√©lectionner les colonnes et d'ajouter une colonne. Cette fonction combine donc les actions de `select` + `mutate`.\n\nLa commande suivante consiste √† calculer une nouvelle variable, √† s√©lectionner les varibles et √† trier selon nouvelle variable cr√©e√©.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  mutate(density = population / land_area) %>% \n  select(state, county, population, density) %>% \n  arrange(density)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 4\n   state      county                     population density\n   <chr>      <chr>                           <dbl>   <dbl>\n 1 Alaska     Yukon-Koyukuk Census Area        5644  0.0388\n 2 Alaska     Lake and Peninsula Borough       1474  0.0623\n 3 Alaska     Yakutat City and Borough          643  0.0841\n 4 Alaska     North Slope Borough              9667  0.109 \n 5 Alaska     Denali Borough                   2060  0.162 \n 6 Alaska     Northwest Arctic Borough         7732  0.217 \n 7 Montana    Garfield                         1047  0.224 \n 8 New Mexico Harding                           565  0.266 \n 9 Montana    Petroleum                         443  0.268 \n10 Alaska     Dillingham Census Area           4979  0.268 \n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nAvec `transmute()`, le code pr√©c√©dent est r√©duit comme suit :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  transmute(state, county, population, density = population / land_area) %>%\n  arrange(density)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 4\n   state      county                     population density\n   <chr>      <chr>                           <dbl>   <dbl>\n 1 Alaska     Yukon-Koyukuk Census Area        5644  0.0388\n 2 Alaska     Lake and Peninsula Borough       1474  0.0623\n 3 Alaska     Yakutat City and Borough          643  0.0841\n 4 Alaska     North Slope Borough              9667  0.109 \n 5 Alaska     Denali Borough                   2060  0.162 \n 6 Alaska     Northwest Arctic Borough         7732  0.217 \n 7 Montana    Garfield                         1047  0.224 \n 8 New Mexico Harding                           565  0.266 \n 9 Montana    Petroleum                         443  0.268 \n10 Alaska     Dillingham Census Area           4979  0.268 \n# ... with 3,128 more rows\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}