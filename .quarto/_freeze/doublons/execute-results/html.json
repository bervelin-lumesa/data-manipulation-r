{
  "hash": "71a776678b299a73c97981e0678f46c6",
  "result": {
    "markdown": "# Gestion des doublons et valeurs manquantes\n\n## Gestion des doublons\n\nLorsque nous travaillons avec des données, il n'est pas rare d'avoir affaire à des doublons, c'est-à-dire des enregistrements qui répètent les mêmes informations. La présence de doublons peut rendre nos analyses moins fiables, car ils peuvent fausser les résultats.\n\nLa détection et suppression des doublons est donc une étape importante de la préparation des données, qui doit être réalisée avant toute analyse.\n\nUne fois que nous avons détecté les doublons, nous pouvons les supprimer avant de continuer nos analyses.\n\nIl est important de documenter le processus de détection et de suppression des doublons afin de pouvoir reproduire les résultats à tout moment et de s'assurer de la qualité des données utilisées pour les analyses.\n\nLe code suivant permet de générer les données sur lesquelles nous allons travailler.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(df <- data.frame(\n  Prenom   = c(rep('Jean',3), rep(\"Alain\", 2)), \n  Activite = c(rep('Foot',3), rep(\"Danse\", 2)), \n  Lieu     = c(rep('Kinshasa',3), rep(\"Goma\", 2)), \n  Date     = as.Date(c(\"2023-05-12\", \"2023-05-16\", \"2023-05-14\", \"2023-05-17\", \"2023-05-13\"))\n                  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Prenom Activite     Lieu       Date\n1   Jean     Foot Kinshasa 2023-05-12\n2   Jean     Foot Kinshasa 2023-05-16\n3   Jean     Foot Kinshasa 2023-05-14\n4  Alain    Danse     Goma 2023-05-17\n5  Alain    Danse     Goma 2023-05-13\n```\n:::\n:::\n\n\n### Détection des doublons\n\nLa fonction `duplicated` permet de détecter les doublons sur toutes les colonnes d'un tableau de données. On peut cependant lui fournir un tableau de données ne contenant que les variables sur lesquelles baser la recherche.\n\nCette fonction retourne `TRUE` si la ligne est un doublon et `FALSE` dans le cas contraire. Ici, nous cherchons les doublons sur les trois premières colonnes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nduplicated(df[, - 4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE FALSE  TRUE\n```\n:::\n:::\n\n\nOn peut ajouter `which()` à la fonction précédente pour retourner les numéros des lignes qui sont des doublons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(duplicated(df[, - 4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 5\n```\n:::\n:::\n\n\nLe code suivant permet d'afficher les doublons détectés dans notre tableau de données.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndup <- which(duplicated(df[, - 4]))\n\ndf[dup, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Prenom Activite     Lieu       Date\n2   Jean     Foot Kinshasa 2023-05-16\n3   Jean     Foot Kinshasa 2023-05-14\n5  Alain    Danse     Goma 2023-05-13\n```\n:::\n:::\n\n\n### Suppression des doublons\n\n#### `duplicated`\n\nPour supprimer les doublons, il suffit d'ajouter le signe négatif à l'objet qui contient les lignes de doublons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndup <- which(duplicated(df[, - 4]))\ndf[-dup, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Prenom Activite     Lieu       Date\n1   Jean     Foot Kinshasa 2023-05-12\n4  Alain    Danse     Goma 2023-05-17\n```\n:::\n:::\n\n\n#### `distinct`\n\n`distinct` fait partie des focntions du package`dplyr` et permet de supprimer les doublons en ne retournant que les observations distinctes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  distinct(Prenom, Activite, Lieu, .keep_all = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Prenom Activite     Lieu       Date\n1   Jean     Foot Kinshasa 2023-05-12\n2  Alain    Danse     Goma 2023-05-17\n```\n:::\n:::\n\n\nL'argument `.keep_all = T` permet de garder toutes les colonnes dans le résultat.\n\n### Retenir les observations par rapport à une date\n\nIl arrive qu'on ait besoin de retenir les observations, non pas par rapport à leur ordre dans le tableau de données, mais par rapport à une autre variable (une date par exemple).\n\nPour ce faire, nous devons d'abord grouper les observations selon la/les variable(s) clés, puis les trier selon la variable contenant le date. Une fois les données triées, nous pouvons sélectionner les premières ou les dernières observations.\n\nLe code suivant permet de retenir les observations dont la date est la plus ancienne\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grouper et Trier par ordre croissant \ndf_cr <- df %>% \n  group_by(Prenom, Activite, Lieu) %>% \n  arrange(Date) \n\ndf_cr %>% \n  distinct(Prenom, Activite, Lieu, .keep_all = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n# Groups:   Prenom, Activite, Lieu [2]\n  Prenom Activite Lieu     Date      \n  <chr>  <chr>    <chr>    <date>    \n1 Jean   Foot     Kinshasa 2023-05-12\n2 Alain  Danse    Goma     2023-05-13\n```\n:::\n:::\n\n\nIci, nous retenons les observations avec la date la plus récente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grouper et Trier par ordre décroissant\ndf_dec <- df %>% \n  group_by(Prenom, Activite, Lieu) %>% \n  arrange(desc(Date)) \n\ndf_dec %>% \n  distinct(Prenom, Activite, Lieu, .keep_all = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n# Groups:   Prenom, Activite, Lieu [2]\n  Prenom Activite Lieu     Date      \n  <chr>  <chr>    <chr>    <date>    \n1 Alain  Danse    Goma     2023-05-17\n2 Jean   Foot     Kinshasa 2023-05-16\n```\n:::\n:::\n\n\nNous pouvons aussi utiliser la fonction `slice` sur le tableau de données groupées et triées comme suit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_dec %>% \n  slice(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n# Groups:   Prenom, Activite, Lieu [2]\n  Prenom Activite Lieu     Date      \n  <chr>  <chr>    <chr>    <date>    \n1 Alain  Danse    Goma     2023-05-17\n2 Jean   Foot     Kinshasa 2023-05-16\n```\n:::\n:::\n\n\nPour sauvegarder le tableau de données sans doublons, il faut l'affecter un à objet.\n\n\n## Gestion des valeurs manquantes\n\nLes données à analyser contiennent souvent des valeurs manquantes, c’est-à-dire des valeurs non renseignées pour une pour plusieurs variables.\n\n- Les valeurs peuvent fausser les analyses, car basées sur peu de données,\n\n- Certains algorithmes sont sensibles aux valeurs manquantes.\n\nSupprimer ou remplacer les valeurs manquantes ?\n\nLa suppression peut réduire sensiblement le nombre d’observations et le remplacement peut négativement affecter la variance. \n\n\n### Détecter les valeurs manquantes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(haven)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntelco <-  haven::read_sav(\"data/telco_missing.sav\")\ndim(telco)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000   30\n```\n:::\n:::\n\n\nPour un vecteur\n\n- `is.na()` : détecte la présence des `NA` sur une colonne (vecteur),\nsum(is.na(vecteur)) : combiner avec `sum()`, pour connaître le nombre de valeurs manquantes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(is.na(telco$age), 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[49] FALSE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(telco$age))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n\nPour un data frame\n\n- `colSums(is.na(dataframe))` : détecte le nombre de valeurs manquantes sur toutes colonnes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(is.na(telco))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  tenure      age  marital  address   income       ed   employ   retire \n      32       25      115      150      179       35       96       84 \n  gender   reside tollfree    equip callcard wireless  longmon  tollmon \n      42       34        0        0        0        0        0        0 \nequipmon  cardmon  wiremon multline    voice    pager internet   callid \n       0        0        0        0        0        0        0        0 \ncallwait  forward   confer    ebill  custcat    churn \n       0        0        0        0        0        0 \n```\n:::\n\n```{.r .cell-code}\ncolSums(is.na(telco)) / nrow(telco)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  tenure      age  marital  address   income       ed   employ   retire \n   0.032    0.025    0.115    0.150    0.179    0.035    0.096    0.084 \n  gender   reside tollfree    equip callcard wireless  longmon  tollmon \n   0.042    0.034    0.000    0.000    0.000    0.000    0.000    0.000 \nequipmon  cardmon  wiremon multline    voice    pager internet   callid \n   0.000    0.000    0.000    0.000    0.000    0.000    0.000    0.000 \ncallwait  forward   confer    ebill  custcat    churn \n   0.000    0.000    0.000    0.000    0.000    0.000 \n```\n:::\n:::\n\n\n\n### Supprimer les valeurs manquantes\n\nLa première solution peut être de supprimer les valeurs manquantes. Préconisée lorsque les manquantes représentent une faible proportion.\n\nPour un vecteur\n\n- `vecteur[!is.na(vecteur)]` ou `vecteur[complete.cases(vecteur)]`\n\n- Certaines fonctions comme mean() disposent de l’argument `na.rm = T` pour supprimer `NA` lors du calcul.\n\n\n::: {.cell run='false'}\n\n```{.r .cell-code}\nhead(telco$age[!is.na(telco$age)], 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 44 33 52 33 30 39 22 35 59 41 35 38 54 46 38 57 48 24 29 30 52 33 48 43 21\n[26] 40 33 21 33 37 53 50 27 46 35 60 57 41 57 41 28 28 36 41 51 41 34 36 34 52\n```\n:::\n:::\n\n\n\nPour un data frame\n\n- `na.omit(dataframe)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntelco2 <- na.omit(telco)\ndim(telco2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 475  30\n```\n:::\n:::\n\n\n\n### Remplacer les valeurs manquants\n\nUne autre alternative est de remplacer les valeurs manquantes. \n\n- On utilise souvent la moyenne ou la médiane. \n\n- D’autres techniques existent… \n\nIci, nous remplaçons les valeurs maquantes par la moyenne.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntelco$age[is.na(telco$age)] <- mean(telco$age, na.rm = T)\nsum(is.na(telco$age))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nmean(telco$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 41.74872\n```\n:::\n:::\n\n\n\nLe code suivant permet de remplacer les valeurs manquantes par la médiane en utilisant la syntaxe de tidyverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntelco3 <- telco %>% \n  mutate(new_income = ifelse(is.na(income), \n                             median(income, na.rm = T),\n                             income)) \ntelco3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 31\n   tenure   age marital     address income ed      employ retire  gender  reside\n    <dbl> <dbl> <dbl+lbl>     <dbl>  <dbl> <dbl+l>  <dbl> <dbl+l> <dbl+l>  <dbl>\n 1     13    44 1 [Married]       9     64 4 [Col…      5  0 [No] 0 [Mal…      2\n 2     11    33 1 [Married]       7    136 5 [Pos…      5  0 [No] 0 [Mal…      6\n 3     68    52 1 [Married]      24     NA 1 [Did…     29  0 [No] 1 [Fem…      2\n 4     33    33 0 [Unmarri…      12     33 2 [Hig…      0  0 [No] 1 [Fem…      1\n 5     23    30 1 [Married]       9     30 1 [Did…     NA NA      0 [Mal…      4\n 6     41    39 0 [Unmarri…      17     78 2 [Hig…     16  0 [No] 1 [Fem…      1\n 7     45    22 1 [Married]       2     19 2 [Hig…      4  0 [No] 1 [Fem…      5\n 8     38    35 0 [Unmarri…       5     76 2 [Hig…     NA  0 [No] 0 [Mal…      3\n 9     45    59 1 [Married]       7    166 4 [Col…     31  0 [No] 0 [Mal…      5\n10     68    41 1 [Married]      21     72 1 [Did…     22  0 [No] 0 [Mal…      3\n# … with 990 more rows, and 21 more variables: tollfree <dbl+lbl>,\n#   equip <dbl+lbl>, callcard <dbl+lbl>, wireless <dbl+lbl>, longmon <dbl>,\n#   tollmon <dbl>, equipmon <dbl>, cardmon <dbl>, wiremon <dbl>,\n#   multline <dbl+lbl>, voice <dbl+lbl>, pager <dbl+lbl>, internet <dbl+lbl>,\n#   callid <dbl+lbl>, callwait <dbl+lbl>, forward <dbl+lbl>, confer <dbl+lbl>,\n#   ebill <dbl+lbl>, custcat <dbl+lbl>, churn <dbl+lbl>, new_income <dbl>\n```\n:::\n\n```{.r .cell-code}\ntelco3 %>% \n  select(income, new_income) %>% \n  filter(is.na(income))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 179 × 2\n   income new_income\n    <dbl>      <dbl>\n 1     NA         46\n 2     NA         46\n 3     NA         46\n 4     NA         46\n 5     NA         46\n 6     NA         46\n 7     NA         46\n 8     NA         46\n 9     NA         46\n10     NA         46\n# … with 169 more rows\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}