{
  "hash": "8f38e7c6bd9b9c9321af9990cb785aee",
  "result": {
    "markdown": "# Recodage de variables et mise en forme de données\n\n## Recodage de variables\n\n\n\n\n\n\n\nIl arrive souvent que nous voulions modifier les modalités d'une variable ou créer des classes à partir d'une variable quantitative.\n\nS'il s'agit d'une condition simple, nous povons utiliser `ifelse()`. Pour des condtions longues, `cut()`, `recode()`, `case_when()` ferons l'affaire.\n\n### ifelse\n\nLa commande suivante permet de créer une variable avec deux modalités sur base de la variable population.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  mutate(population_group = ifelse(population > 25000, \">25000\", \"<=25000\")) %>% \n  select(population, population_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 2\n   population population_group\n        <dbl> <chr>           \n 1      55221 >25000          \n 2     195121 >25000          \n 3      26932 >25000          \n 4      22604 <=25000         \n 5      57710 >25000          \n 6      10678 <=25000         \n 7      20354 <=25000         \n 8     116648 >25000          \n 9      34079 >25000          \n10      26008 >25000          \n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\n### recode\n\nAvec `recode()`, la syntaxe est la suivante : `recode(variable, \"ancienne_valeur\" = \"nouvelle_valeur\")`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  mutate(metro_new = recode(metro, \n                            \"Metro\" = \"Avec Metro\", \n                            \"Nonmetro\" = \"Sans metro\")) %>% \n  count(metro_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  metro_new      n\n  <chr>      <int>\n1 Avec Metro  1165\n2 Sans metro  1973\n```\n:::\n:::\n\n\n\n### case_when\n\n`case_when()` est une une généralisation du `ifelse()` au cas où nous avons plusieurs conditions à vérifier. Nous pouvons créer une variable catégorielle à partir de la variable quantitative.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(income) %>% \n  mutate(income_cat = case_when(\n    income >= 17000 & income <= 40000 ~ \"17000-40000\",\n    income > 40000 & income <= 46000 ~ \"40001-46000\",\n    income > 46000 & income <= 50000 ~ \"46001-50000\",\n    TRUE ~ \">50000\"\n  )) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 2\n   income income_cat \n    <dbl> <chr>      \n 1  51281 >50000     \n 2  50254 >50000     \n 3  32964 17000-40000\n 4  38678 17000-40000\n 5  45813 40001-46000\n 6  31938 17000-40000\n 7  32229 17000-40000\n 8  41703 40001-46000\n 9  34177 17000-40000\n10  36296 17000-40000\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nLa clause TRUE \\~ \"\\>50000\" permet d'assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n'est vraie.\n\nLe même résultat peut être obtenu avec `cut()`.\n\n### cut\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(income) %>% \n  mutate(\n    income_cat = cut(\n      income,\n      breaks = c(17000, 40000, 46000, 50000, 150000),\n      labels = c(\"17000-40000\", \"40001-46000\", \"46001-50000\", \">50000\")\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 x 2\n   income income_cat \n    <dbl> <fct>      \n 1  51281 >50000     \n 2  50254 >50000     \n 3  32964 17000-40000\n 4  38678 17000-40000\n 5  45813 40001-46000\n 6  31938 17000-40000\n 7  32229 17000-40000\n 8  41703 40001-46000\n 9  34177 17000-40000\n10  36296 17000-40000\n# ... with 3,128 more rows\n```\n:::\n:::\n\n\n\nL'argument `include_lowest = T` peut être ajouté à `cut()` pour inclure la valeur minimale dans la première classe.\n\n## Mettre les données en ordre (wide - long format)\n\nL'objectif du package tidyr est de fournir des fonctions pour arranger ses données et les convertir dans un format tidy. Quand est-ce que les données sont dans un format tidy ?\n\nLe concept de tidy data repose sur trois règles interdépendantes. Des données sont considérées comme tidy si :\n\n1.  chaque ligne correspond à une observation\n\n2.  chaque colonne correspond à une variable\n\n3.  chaque valeur est présente dans une unique case de la table ou, de manière équivalente, des unités d'observations différentes sont présentes dans des tables différentes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry <- c(\"Belgium\", \"France\", \"Germany\", \"Italy\", \"Spain\", \"Switzerland\")\n`2002` <- c(10311970, 59925035, 82350671, 57926999, 40152517, 7361757)\n`2007` <- c(10392226, 61083916, 82400996, 58147733, 40448191, 7554661)\n\n(df <- tibble(\n  country,\n  `2002`,\n  `2007`\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  country       `2002`   `2007`\n  <chr>          <dbl>    <dbl>\n1 Belgium     10311970 10392226\n2 France      59925035 61083916\n3 Germany     82350671 82400996\n4 Italy       57926999 58147733\n5 Spain       40152517 40448191\n6 Switzerland  7361757  7554661\n```\n:::\n:::\n\n\n\n\n\n### pivot_longer : transformer des colonnes en lignes\n\nIci nous rassemblons les colonnes `2002` et `2007` sous `year` et les différentes valeurs dans `population`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long <- df %>%\n  pivot_longer(cols = c(`2002`, `2007`), names_to = \"year\", values_to = \"population\")\n\ndf_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 x 3\n   country     year  population\n   <chr>       <chr>      <dbl>\n 1 Belgium     2002    10311970\n 2 Belgium     2007    10392226\n 3 France      2002    59925035\n 4 France      2007    61083916\n 5 Germany     2002    82350671\n 6 Germany     2007    82400996\n 7 Italy       2002    57926999\n 8 Italy       2007    58147733\n 9 Spain       2002    40152517\n10 Spain       2007    40448191\n11 Switzerland 2002     7361757\n12 Switzerland 2007     7554661\n```\n:::\n:::\n\n\n\nAvec l'argument `cols =` on spécifie les noms des colonnes qui deviendront des modalités de la variable dont le nom est déterminé dans `names_to =`. `values_to =` détermine la variable qui contiendra les valeurs.\n\n### pivot_wider : transformer des lignes en colonnes\n\n`pivot_wider` de réaliser l'opération inverse que `pivot_longer`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long %>% \n  pivot_wider(names_from = \"year\", values_from = \"population\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  country       `2002`   `2007`\n  <chr>          <dbl>    <dbl>\n1 Belgium     10311970 10392226\n2 France      59925035 61083916\n3 Germany     82350671 82400996\n4 Italy       57926999 58147733\n5 Spain       40152517 40448191\n6 Switzerland  7361757  7554661\n```\n:::\n:::\n\n\n\nDans `names_from =` nous indiquons la variable à partir de laquelle créer des colonnes.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}