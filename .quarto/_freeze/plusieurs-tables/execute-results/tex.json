{
  "hash": "e1c9aa66f48e512af1e9fc9456f0189d",
  "result": {
    "markdown": "# Combiner plusieurs tableaux de données\n\n\n\n\n\n\n\nSouvent, l'analyse de données implique plusieurs jeux de données reliés, au lieu d'un seul. Ces différents jeux de données doivent être combinés pour pouvoir répondre à la question qui vous intéresse. Les différentes tables de données liées forment ce qu'on appelle une base de données relationnelles.\n\nPour pouvoir relier les différents tables de données, ces dernières doivent posséder des clés (keys) permettant d'établir ce lien. Une clé identifie une observation de façon unique.\n\nIl y a deux types de clés :\n\n-   clé primaire : identifie une observation de façon unique dans sa propre table.\n\n-   clé étrangère : identifie une observation dans une autre table.\n\nPar exemple, dans les enquêtes du type EDS, nous pouvons avoir une table de données de ménage et une table de données des femmes. Le numéro du ménage dans la table ménage constitue la clé primaire. Dans la table de données des femmes, ce même numéro constitue une clé étrangère.\n\nNous allons utiliser deux tables de données (`personnes` et `voitures`) pour illustrer l'utilisation des jointures.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes <- tibble(\n  nom = c(\"Sylvie\", \"Sylvie\", \"Monique\", \"Gunter\", \"Rayan\", \"Rayan\"),\n  voiture = c(\"Twingo\", \"Ferrari\", \"Scenic\", \"Lada\", \"Twingo\", \"Clio\")\n)\n\nvoitures <- tibble(\n  voiture = c(\"Twingo\", \"Ferrari\", \"Clio\", \"Lada\", \"208\"),\n  vitesse = c(\"140\", \"280\", \"160\", \"85\", \"160\")\n)\n\npersonnes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 2\n  nom     voiture\n  <chr>   <chr>  \n1 Sylvie  Twingo \n2 Sylvie  Ferrari\n3 Monique Scenic \n4 Gunter  Lada   \n5 Rayan   Twingo \n6 Rayan   Clio   \n```\n:::\n\n```{.r .cell-code}\nvoitures\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n  voiture vitesse\n  <chr>   <chr>  \n1 Twingo  140    \n2 Ferrari 280    \n3 Clio    160    \n4 Lada    85     \n5 208     160    \n```\n:::\n:::\n\n\n\n## inner_join\n\nRetourne uniquement les lignes présentes dans les deux tables.\n\n![inner_join](images/inner.PNG){fig-align=\"center\"}\n\nLorsque les clés portent le même nom, il n'est important de préciser cette variable dans l'appel de la fonction. Mais lorsque les clés ont des noms différents, il devient alors obligatoire de préciser les noms des variables clés avec l'argument `by = c(\"cle_x\" = \"cle_y\")` au sein de la fonction de jointure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% inner_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n  nom    voiture vitesse\n  <chr>  <chr>   <chr>  \n1 Sylvie Twingo  140    \n2 Sylvie Ferrari 280    \n3 Gunter Lada    85     \n4 Rayan  Twingo  140    \n5 Rayan  Clio    160    \n```\n:::\n:::\n\n\n\nEn précisant explicitement la clé :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% inner_join(voitures, by = c(\"voiture\" = \"voiture\"))\n```\n:::\n\n\n\n## left_join\n\nDonne toutes les lignes de la première table avec les lignes de la deuxième table si elles ont une clé correspondante. Les lignes de la première table sans correspondance dans la deuxième auront des 'NA'. Les lignes de la deuxième table sans correspondance avec la première seront supprimées. L'image ci-après illustre le fonctionnement de `left_join()`.\n\n![left_join](images/left.PNG){fig-align=\"center\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% left_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  nom     voiture vitesse\n  <chr>   <chr>   <chr>  \n1 Sylvie  Twingo  140    \n2 Sylvie  Ferrari 280    \n3 Monique Scenic  <NA>   \n4 Gunter  Lada    85     \n5 Rayan   Twingo  140    \n6 Rayan   Clio    160    \n```\n:::\n:::\n\n\n\n## right_join\n\n`right_join()` est juste l'opposé de `left_join()`. Donne toutes les lignes de la deuxième table avec les lignes de la première table si elles ont une clé correspondante. Les lignes de la deuxième table sans correspondance dans la première auront des 'NA'. Les lignes de la première table sans correspondance avec la deuxième seront supprimées comme le montre l'image suivante.\n\n![right_join](images/right.PNG){fig-align=\"center\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% right_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  nom    voiture vitesse\n  <chr>  <chr>   <chr>  \n1 Sylvie Twingo  140    \n2 Sylvie Ferrari 280    \n3 Gunter Lada    85     \n4 Rayan  Twingo  140    \n5 Rayan  Clio    160    \n6 <NA>   208     160    \n```\n:::\n:::\n\n\n\n## full_join\n\n![full_join](images/full.PNG){fig-align=\"center\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% full_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 3\n  nom     voiture vitesse\n  <chr>   <chr>   <chr>  \n1 Sylvie  Twingo  140    \n2 Sylvie  Ferrari 280    \n3 Monique Scenic  <NA>   \n4 Gunter  Lada    85     \n5 Rayan   Twingo  140    \n6 Rayan   Clio    160    \n7 <NA>    208     160    \n```\n:::\n:::\n\n\n\nRetourne toutes les lignes de deux tables, même si elles ne sont pas disponibles dans l'une ou l'autre table.\n\n------------------------------------------------------------------------\n\nL'image suivante donne un rsumé de différentes jointures mutate (qui ajoutent des colonnes) sous forme de diagramme de Venn.\n\n\\\n![diagramme de venn](images/venn-dia.PNG){fig-align=\"center\"}\n\nContrairement aux jointures vues jusqu'ici, celles qui suivent n'ajoutent pas de colonnes (variables) à la première table de données. On les qualifie de jointures filtrantes.\n\n## semi_join\n\nRetourne les lignes de la première table qui ont des correspondances dans la deuxième table, sans ajouter les colonnes de cette dernière.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% semi_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n  nom    voiture\n  <chr>  <chr>  \n1 Sylvie Twingo \n2 Sylvie Ferrari\n3 Gunter Lada   \n4 Rayan  Twingo \n5 Rayan  Clio   \n```\n:::\n:::\n\n\n\n## anti_join\n\nRetourne les lignes de la première table qui n'ont pas de correspondances dans la deuxième table, sans ajouter les colonnes de cette dernière.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% anti_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  nom     voiture\n  <chr>   <chr>  \n1 Monique Scenic \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}