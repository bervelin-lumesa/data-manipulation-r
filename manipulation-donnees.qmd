# Manipulation de donn√©es avec dplyr

La manipulation de donn√©es est l'une des comp√©tences les plus importantes en science des donn√©es, car elle permet de nettoyer, transformer et regrouper des donn√©es brutes en des ensembles de donn√©es utiles et informatifs. R est un langage de programmation populaire pour la science des donn√©es qui offre une grande vari√©t√© de fonctions et de packages pour effectuer ces t√¢ches. De la s√©lection de colonnes sp√©cifiques √† la transformation de donn√©es en utilisant des fonctions personnalis√©es, en passant par la fusion de ensembles de donn√©es diff√©rents, la manipulation de donn√©es avec R est un art qui n√©cessite une bonne compr√©hension des outils adapt√©s. Dans ce chapitre, nous allons explorer les techniques de la manipulation de donn√©es avec R et quelques packages dont principalement `dplyr`.

## Introduction au pipe (`%>%`)

Quand on manipule un tableau de donn√©es, il est tr√®s fr√©quent d'encha√Æner plusieurs op√©rations. On va par exemple extraire une sous-population avec `filter`, s√©lectionner des colonnes avec `select` puis trier selon une variable avec `arrange`, etc.

```{r warning=FALSE, message=FALSE}
library(tidyverse)
counties <- readRDS("data/counties.rds")
```

TRaditionnellement, nous pouvons √©crire ceci :

```{r}
count(
  ungroup(
  slice_max(
  summarize(
    group_by(counties, state, metro), 
    total_pop = sum(population)),
  total_pop, n = 1)), 
  metro)

```

Pour simplifier et am√©liorer la lisibilit√© du code, on va utiliser un op√©rateur, pipe. Le pipe se note `%>%`, et son fonctionnement est le suivant : si j'ex√©cute expr `%>%` f, alors le r√©sultat de l'expression expr, √† gauche du pipe, sera pass√© comme premier argument √† la fonction f, √† droite du pipe, ce qui revient √† ex√©cuter `f(expr)`.

Ainsi le premier code peut s'"crire comme suit, en utilisant le pipe :

```{r}
counties %>%
  group_by(state, metro) %>%
  summarize(total_pop = sum(population)) %>%
  slice_max(total_pop, n = 1) %>%
  ungroup() %>%
  count(metro)
```

On voit bien ce code est plus clair, car les op√©rations sont √©crites dans l'ordre naturelle.

Les donn√©es (`counties`) que nous allons utiliser contiennent les comt√©s des diff√©rents Etats aux USA avec des diff√©rents indicateurs.

## Les verbes de dplyr

Manipuler les donn√©es avec dplyr se fait au moyen d'un certain nombre de verbes qui indique l'action √† ex√©cuter le tableau de donn√©es (data.frame/tibble). Toutes les fonctions que nous verons prennent un dataframe en entr√©e et retourne √©galement un datafrme.

### select

Permet de s√©lectionner une ou plusieurs colonnes d'un tableau de donn√©e.

```{r}
counties %>%
  # Selectionner 4 colonnes
  select(state, county, population, poverty)
```

Les `:` permettent de s√©lectionner des colonnes qui se suivent.

```{r}
counties %>% 
  select(metro : black)
```

La commande suivante permet de s√©lectionner les colonnes dont les noms commencent avec "in".

```{r}
counties %>% 
  select(starts_with("in"))
```

On peut aussi utiliser `contains()` ou `ends_with()` pour s√©lectionner respectivement les colonnes qui contiennent ou se se terminent par une cha√Æne de caract√®re donn√©e. Des colonnes peuvent √™tre exclues du r√©sultat par le signe (-). On peut par exemple exclure les 6 premi√®res colonnes.

```{r results='hide'}
counties %>% 
  select(-c(1 : 6))
```

üëâ S√©lectionnez les colonnes dont les noms se terminent par "tion". Le r√©sultat devrait ressembler √† √ßa :

```{r echo=FALSE}
counties %>% 
  select(ends_with("tion"))
```

### arrange

Permet de trier une colonne selon un ordre donn√©.

Par d√©faut, `arrange()` trie le r√©sultat par ordre croissant.

```{r}
counties_selected <- counties %>%
  select(region, state, county, public_work, population, private_work, women, citizens, work_at_home, walk, land_area)

counties_selected %>%
  arrange(public_work)
```

On peut obtenir le r√©sultat par ordre d√©croissant avec la fonction `desc()` comme suit :

```{r results='hide'}
counties_selected %>%
  # trier par ordre d√©croissant de 'public_work'
  arrange(desc(public_work))
```

üëâ Quelle est la comt√© avec la plus grande population et celle avec la petite populaion?

```{r eval=FALSE, include=FALSE}
counties_selected %>% 
  arrange(desc(population))
```

```{r eval=FALSE, include=FALSE}
counties_selected %>% 
  arrange(population)
```

### filter

Permet de s√©lectionner des lignes d'un dataframe selon une ou plusieurs conditions.

La commande suivante permet de filtrer les comt√©s ayant une population sup√©rieure √† 1000000.

```{r}
counties_selected %>%
  # filtrer les comt√©s avec une population sup √† 1000000
  filter(population > 1000000)
```

On peut combiner plusieurs conditions avec des op√©rateurs(\| pour OU, & et ',' pour ET, == pour l'√©galit√©).

```{r}
counties_selected %>%
  # filtrer les comt√©s avec une population sup √† 1000000 √† California
  filter(population > 1000000, state == "California")
```

Plusieurs verbes peuvent √™tre encha√Æn√©s avec le pipe.

```{r}
counties_selected %>%
  filter(state == "Texas", population > 10000) %>%
  arrange(desc(private_work))
```

### mutate

Permet d'ajouter une nouvelle variable dans le dataframe. Elle est souvent utiliser pour cr√©er une variable √† partir sur base d'un calcul.

La commande suivante permet cr√©er une variable qui contient le nombre d'employ√©s du secteur public `public_workers` √† partir de `population` et `public_work`.

```{r}
counties_selected %>%
  mutate(public_workers = population * public_work / 100)
```

On peut savoir la comt√© avec le plus grand nombre de d'employ√©s du secteur public.

```{r}
counties_selected %>%
  mutate(public_workers = public_work * population / 100) %>%
  arrange(desc(public_workers)) %>% 
  select(state, county, public_workers)
```

üëâ Quelles sont les 5 comt√©s ayant la plus grande proportion des femmes ?

```{r echo=FALSE}
counties_selected %>% 
  mutate(proportion_women = women / population) %>% 
  arrange(desc(proportion_women)) %>% 
  select(state, county, proportion_women) %>% 
  head(5)
```

### count

Permet de compter le nombre d'occurrence de valeurs d'une variable qualitative.

Le code suivant permet de compter le nombre de comt√©s dans chaque r√©gion.

```{r}
counties_selected %>% 
  count(region, sort = T)
```

`count()` dispose d'un argument `wt` qui permet de fournir une variable quantitative pour effectuer la somme. La commande suivante calcule la somme de la variable `citizens` pour chaque region.

```{r}
counties_selected %>% 
  count(region, wt = citizens, sort = T)
```

Le nombre de personnes qui travaillent √† la maison dans chaque √©tat peut √™tre obtenu avec la commande suivante :

```{r}
counties_selected %>% 
  mutate(pop_work_at_home = population * work_at_home / 100) %>% 
  count(state, wt = pop_work_at_home, sort = T)
```

üëâ Calculer le nombre de personnes qui font la marche pour se rendre au travail.

```{r echo=FALSE}
counties_selected %>%
  mutate(population_walk = population * walk / 100) %>%
  count(state, wt = population_walk, sort = T)
```

### summarize

Permet de calculer un sommaire sur une variable quantitative. Exp: moyenne, √©cart-type

La commande suivante compte le nombre d'observations dans le tableau de donn√©es.

```{r}
counties_selected %>% 
  summarise(n = n())
```

Nous pouvons calcaler plusieurs statistiques telles que la moyenne, minimum, √©cart-type et autres comme sur la commande suivante :

```{r}
counties_selected %>% 
  summarise(
    # calcule le minimum
    min_population = min(population),
    # calcule la moyenne
    mean_population = mean(population),
    # calcule le maximum
    max_population = max(population)
  )
```

### group_by() / ungroup()

Permet de grouper un dataframe en fonction d'une variable qualitative. Cela permet d'effectuer des op√©rations sur ce groupe.

Le groupe n'a de valeur que lorsqu'il est combin√© avec d'autres verbes. Des exemples sont fournis ci-apr√®s :

-   Calculer pour chaque Etat, la superficie et la population totale.

```{r}
counties_selected %>%
  # Group by state 
  group_by(state) %>%
  # Find the total area and population
  summarise(
    total_area = sum(land_area),
    total_population = sum(population)
  )
```

On peut ajouter des verbes √† la commande pr√©c√©dente pour calculer la densit√© et la trier par ordre d√©croissant.

```{r}
counties_selected %>%
  group_by(state) %>%
  summarize(total_area = sum(land_area),
            total_population = sum(population)) %>%
  mutate(density = total_population / total_area) %>%
  arrange(desc(density))
```

-   L'Etat avec le plus faible revenu dans chaque region

```{r}
counties_selected <- counties %>%
  select(region, state, county, population, income)

counties_selected %>%
  group_by(region, state) %>%
  # Calculate average income
  summarise(average_income = mean(income)) %>%
  # Find the lowest income state in each region
  slice_min(average_income, n = 1)
```

-   Deux Etats avec le taux de pauvret√© le plus √©lev√© dans chaque region

```{r}
counties %>% 
  group_by(region, state) %>% 
  summarise(average_poverty = mean(poverty)) %>% 
  slice_max(average_poverty, n = 2)
```

```{r}
counties %>%
  group_by(region) %>%
  summarise(across(ends_with("tion"), mean, .names = "mean_{.col}"))
```

### rename

Permet de renommer le nom d'une colonne (variable). La syntaxe est la suivante : `rename(nouveau_nom = ancien_nom)`.

```{r}
counties_selected <- counties %>%
  select(census_id, region, state, county, population, income)

counties_selected %>% 
  rename(id = census_id, us_state = state)
```

Si l'on d√©sire ne garder que les colonnes r√©nomm√©es, on peut utiliser `select()`.

```{r}
counties %>% 
  select(id = census_id, us_state = state)
```

### transmute

Permet de s√©lectionner les colonnes et d'ajouter une colonne. Cette fonction combine donc les actions de `select` + `mutate`.

La commande suivante consiste √† calculer une nouvelle variable, √† s√©lectionner les varibles et √† trier selon nouvelle variable cr√©e√©.

```{r}
counties %>% 
  mutate(density = population / land_area) %>% 
  select(state, county, population, density) %>% 
  arrange(density)
```

Avec `transmute()`, le code pr√©c√©dent est r√©duit comme suit :

```{r}
counties %>%
  transmute(state, county, population, density = population / land_area) %>%
  arrange(density)
```
